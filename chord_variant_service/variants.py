# Possible operations: eq, lt, gt, le, ge, co
# TODO: Regex verification with schema, to front end

from chord_lib.search import *


__all__ = [
    "VARIANT_SCHEMA",
    "VARIANT_TABLE_METADATA_SCHEMA",
    "SampleVariant",
]


VARIANT_SCHEMA = {
    "$id": "TODO",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "description": "CHORD variant data type",
    "type": "object",
    "required": ["assembly_id", "chromosome", "start", "end", "ref", "alt", "sample_id"],
    "search": {
        "operations": [],
    },
    "properties": {
        "assembly_id": {
            "type": "string",
            "enum": ["GRCh38", "GRCh37", "NCBI36", "Other"],
            "search": {
                "operations": [SEARCH_OP_EQ],
                "canNegate": False,
                "required": False,
                "type": "single",
                "order": 0
            }
        },
        "chromosome": {
            "type": "string",
            # TODO: Choices
            "search": {
                "operations": [SEARCH_OP_EQ],
                "canNegate": False,
                "required": True,
                "type": "single",  # single / unlimited
                "order": 1
            }
        },
        "start": {
            "type": "integer",
            "search": {
                "operations": [SEARCH_OP_GE, SEARCH_OP_LE],  # TODO: Expand this
                "canNegate": False,
                "required": True,
                "type": "unlimited",  # single / unlimited
                "order": 2
            }
        },
        "end": {
            "type": "integer",
            "search": {
                "operations": [SEARCH_OP_EQ, SEARCH_OP_LT, SEARCH_OP_LE, SEARCH_OP_GT, SEARCH_OP_GE],
                "canNegate": True,
                "required": False,
                "type": "unlimited",  # single / unlimited
                "order": 3
            }
        },
        "ref": {
            "type": "string",
            "search": {
                "operations": [SEARCH_OP_EQ],
                "canNegate": True,
                "required": False,
                "type": "single",  # single / unlimited
                "order": 4
            }
        },
        "alt": {
            "type": "string",
            "search": {
                "operations": [SEARCH_OP_EQ],
                "canNegate": True,
                "required": False,
                "type": "single",  # single / unlimited
                "order": 5
            }
        },
        "sample_id": {
            "type": "string",
            "search": {
                "operations": [SEARCH_OP_EQ],
                "canNegate": True,
                "required": False,
                "type": "single",
                "order": 6
            }
            # TODO: Only searchable via join
        }
    }
}

VARIANT_TABLE_METADATA_SCHEMA = {
    "$id": "TODO",
    "$schema": "http://json-schema.org/draft-07/schema#",
    "description": "CHORD variant data type metadata schema",
    "type": "object",
    "required": [],
    "properties": {
        "created": {
            "type": "string",
            "chord_autogenerated": True  # TODO: Extend schema
        },
        "updated": {
            "type": "string",
            "chord_autogenerated": True  # TODO: Extend schema
        }
    }
}


class SampleVariant:
    """
    Instance of a variant on a sample.
    """

    def __init__(self, assembly_id: str, chromosome: str, ref_bases: str, alt_bases: str, start_pos: int,
                 sample_id: str):
        self.assembly_id: str = assembly_id  # Assembly ID for context
        self.chromosome: str = chromosome  # Chromosome where the variant occurs
        self.ref_bases: str = ref_bases  # Reference bases
        self.alt_bases: str = alt_bases  # Alternate bases  TODO: Structural variants
        self.start_pos: int = start_pos  # Starting position on the chromosome w/r/t the reference
        self.sample_id: str = sample_id  # Sample ID which possesses this variant
        # TODO: Genotype

    @property
    def end_pos(self) -> int:
        return self.start_pos + len(self.ref_bases)  # TODO: Ref bases or alt bases? Does this make sense at all?

    def as_chord_representation(self):
        return {
            "assembly_id": self.assembly_id,
            "chromosome": self.chromosome,
            "start": self.start_pos,
            "end": self.end_pos,
            "ref": self.ref_bases,
            "alt": self.alt_bases,
            "sample_id": self.sample_id
        }

    def __eq__(self, other):
        if not isinstance(other, SampleVariant):
            return False

        return (((self.assembly_id is None and other.assembly_id is None) or self.assembly_id == other.assembly_id) and
                self.chromosome == other.chromosome and
                self.ref_bases == other.ref_bases and
                self.alt_bases == other.alt_bases and
                self.start_pos == other.start_pos and
                self.sample_id == other.sample_id)
